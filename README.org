* AI Code Interface

An Emacs interface for AI-assisted software development. *The purpose is to provide a uniform interface and experience for different AI backend*. It is also designed to integrate seamlessly with AI-driven agile development workflow.

- Current it support these AI coding CLI:
  - [[https://github.com/anthropics/claude-code][Claude Code]]
  - [[https://github.com/google-gemini/gemini-cli][Gemini CLI]]
  - [[https://github.com/openai/codex][OpenAI Codex]]
  - [[https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli][GitHub Copilot CLI]]

- I switch across different CLI based AI tool in emacs: Claude Code / Gemini CLI / Aider / OpenAI Codex. If you also use different AI tools inside emacs, but want to keep same user interface and experience, this package is for you.

- Lots of feature and tool ported from [[https://github.com/tninja/aider.el][aider.el]], if you like the feature in aider.el, but wish to switch to modern AI coding CLI, this package is also for you.

- Screenshot

[[./transient_menu.png]]

** Installation

*** Using straight.el

#+begin_src emacs-lisp
  (use-package ai-code-interface
    :straight (:host github :repo "tninja/ai-code-interface.el")
    :config
    (ai-code-set-backend  'claude-code-ide) ;; use claude-code-ide as backend
    ;; Enable global keybinding for the main menu
    (global-set-key (kbd "C-c a") #'ai-code-menu)
    ;; Optional: Set up Magit integration for AI commands in Magit popups
    (with-eval-after-load 'magit
      (ai-code-magit-setup-transients)))
#+end_src

** Usage

*** Backend Configuration
    This package acts as a generic interface that requires a backend AI assistant package to function. You can configure it to work with different backends.

   - Press `C-c a` to open the AI menu, then `s` to "Select Backend".
   - Pick one of the supported backends and the integration will switch immediately.
   - The selection updates the start/switch/send commands and the CLI used by `ai-code-apply-prompt-on-current-file`.

   Supported options:
   - Claude Code (`[[https://github.com/stevemolitor/claude-code.el][claude-code.el]]`)
   - Claude Code IDE (`[[https://github.com/manzaltu/claude-code-ide.el][claude-code-ide.el]]`)
   - Gemini CLI (`[[https://github.com/linchen2chris/gemini-cli.el][gemini-cli.el]]`)
   - [[https://github.com/openai/codex][OpenAI codex CLI]] (`[[./ai-code-codex-cli.el][ai-code-codex-cli.el]]`)
   - [[https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli][GitHub Copilot CLI]] (`[[./ai-code-github-copilot-cli.el][ai-code-github-copilot-cli.el]]`)

   You can add other backends by customizing the `ai-code-backends` variable.

** Key Features

- *Transient-Driven Hub (`C-c a`)*: One keystroke opens a contextual transient menu that groups every capability (CLI control, code actions, agile workflows, utilities) so you never need to memorize scattered keybindings.
- *AI CLI Session Management*: Start (`a`), resume (`R`), or jump back into (`z`) the active AI CLI buffer, instantly swap backends (`s`), upgrade them (`u`), edit backend configs (`g`), and run prompts against the current file (`|`).
- *Context-Aware Code Actions*: The menu exposes dedicated entries for changing code (`c`), implementing TODOs (`i`), asking questions (`q`), explaining code (`x`), sending free-form commands (`<SPC>`), and refreshing AI context (`@`). Each command automatically captures the surrounding function, region, or clipboard contents (via `C-u`) to keep prompts precise.
- *Agile Development Workflows*: Use the refactoring navigator (`r`), the guided TDD cycle (`t`), and the pull/review diff helper (`v`) to keep AI-assisted work aligned with agile best practices. Prompt authoring is first-class through quick access to the prompt file (`p`), block sending (`b`), and AI-assisted shell/file execution (`!`).
- *Productivity & Debugging Utilities*: Initialize project navigation assets (`.`), investigate exceptions (`e`), auto-fix Flycheck issues in scope (`f`), copy or open file paths formatted for prompts (`k`, `o`), generate MCP inspector commands (`m`), and capture session notes straight into Org (`n`).
- *Seamless Prompt Management*: Open `.ai.code.prompt.org`, send regions with `ai-code-prompt-send-block`, and reuse prompt snippets via `yasnippet` to keep conversations organized.
- *Interactive Chat & Context Tools*: Dedicated buffers hold long-running chats, automatically enriched with file paths, diffs, and history from Magit or Git commands for richer AI responses.
- *AI-Assisted Bash Commands*: From Dired, shell, eshell, or vterm, run `C-c a !` and type natural-language commands prefixed with `:` (e.g., `:count lines of python code recursively`); the tool generates the shell command for review and executes it in a compile buffer.

*** Typical Workflows
    - *Changing Code*: Position the cursor on a function or select a region of code. Press `C-c a`, then `c` (`ai-code-code-change`). Describe the change you want to make in the prompt. The AI will receive the context of the function or region and your instruction.
    - *Implementing a TODO*: Write a comment in your code, like `;; TODO: Implement caching for this function`. Place your cursor on that line and press `C-c a`, then `i` (`ai-code-implement-todo`). The AI will generate the implementation based on the comment.
    - *Asking a Question*: Place your cursor within a function, press `C-c a`, then `q` (`ai-code-ask-question`), type your question, and press Enter. The question, along with context, will be sent to the AI.
    - *Refactoring a Function*: With the cursor in a function, press `C-c a`, then `r` (`ai-code-refactor-book-method`). Select a refactoring technique from the list, provide any required input (e.g., a new method name), and the prompt will be generated.
    - *Reviewing a Pull Request*: Press `C-c a`, then `v` (`ai-code-pull-or-review-diff-file`). Choose to generate a diff between two branches. The diff will be created in a new buffer, and you'll be prompted to start a review. 

** Add a new AI coding CLI backend 

- [[https://github.com/tninja/ai-code-interface.el/pull/2][This PR]] add the github-copilot-cli (require claude-code.el). It can be an example to add basic support for other AI coding CLI.

- Open a issue, Post information about the new AI coding CLI backend (eg. cursor CLI?), at least providing the command line name. You can also include the version upgrade command, how to resume, where the configuration files are located, and so on. We can ask GitHub Copilot to add support features based on the issue.

** [[https://github.com/tninja/aider.el/blob/main/appendix.org#be-careful-about-ai-generated-code][Why Agile development with AI?]]

** Dependencies

*** Required Dependencies
- Emacs 26.1 or later
- `org`: Org-mode support
- `magit`: Git integration
- `transient`: For the menu system
- Claude Code (`[[https://github.com/stevemolitor/claude-code.el][claude-code.el]]`)

*** Optional Dependencies
- `helm`: For an enhanced auto-completion experience (`ai-code-input.el`).
- `yasnippet`: For snippet support in the prompt file. A library of snippets is included.
- `gptel`: For intelligent, AI-generated headlines in the prompt file.
- `flycheck`: To enable the `ai-code-flycheck-fix-errors-in-scope` command.
- `projectile`: For project root initialization.
- `helm-gtags`: For tags creation.

** Related emacs packages
- Claude Code (`[[https://github.com/stevemolitor/claude-code.el][claude-code.el]]`)
- Claude Code IDE (`[[https://github.com/manzaltu/claude-code-ide.el][claude-code-ide.el]]`)
- Gemini CLI (`[[https://github.com/linchen2chris/gemini-cli.el][gemini-cli.el]]`)
- [[https://github.com/xenodium/agent-shell][agent-shell]] ([[https://github.com/xenodium/acp.el][acp.el]])

** License

Apache-2.0 License

** Contributing

Contributions, issue reports, and improvement suggestions are welcome! Please open an issue or submit a pull request on the project's GitHub repository.
